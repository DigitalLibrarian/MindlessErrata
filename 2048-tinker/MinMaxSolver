var gm = new GameManager(4, KeyboardInputManager, HTMLActuator, LocalStorageManager);

var PUMPTIME = 3000;
var MAX_BOARD_SCORE = Number.MaxValue;
var MIN_BOARD_SCORE = -Number.MaxValue;
var totalMoves = 0;
// 0: up
// 1: right
// 2: down
// 3: left
function sim()
{
	if(!gm.over)
	{
		var move = GetMove(6);

		gm.move(move);
		console.log("Move: " + move);

		totalMoves++;
		setTimeout(sim, PUMPTIME)
	}
	else
	{
		console.log('Game Over: ' + gm.score);
		console.log("Total moves: " + totalMoves);
	}
}


function GetMove(levelsDeep)
{
	var board = ExtractBoard();
	console.log("Generating move.  current board score = " + FindMaxValue(board));
	var originalBoard = CopyBoard(board);
	var playerMove = {move: 0};

	var bestHigh = MinMaxMove(true, levelsDeep, board, playerMove);

	var newBoard = HumanMove(board, playerMove.move);
	// if our ai didn't turn up anything useful, let's fall back on the first direction that yields *something* different
	if(IsSameBoard(newBoard, originalBoard)){
		for(var retry = 0; retry < 4; retry++){	
			newBoard = HumanMove(board, retry);
			if(!IsSameBoard(newBoard, originalBoard)){
				return retry;
			}
		}
	}

	return playerMove.move;
}


function MinMaxMove(isMyTurn, levelsLeft, board, playerMove)
{
	if(levelsLeft == 0) {
		return FindMaxValue(board);
	}
	

	if(isMyTurn) { 	return HumanTurn(levelsLeft, board, playerMove); }
	else 	     {	return AiTurn(levelsLeft, board); }
}

function AiTurn(levelsLeft, board){
	var choices = [2, 4];
	var possibleCells = ComputePossibleCells(board);


	if(possibleCells.length == 0)
	{
		return FindMaxValue(board);
	}

	var bestHigh = MAX_BOARD_SCORE;
	var bestChoice = 2;
	var bestCell = {x:0, y:0};

	for(var choiceIndex = 0; choiceIndex < choices.length;choiceIndex++){
		for(var cellIndex = 0; cellIndex < possibleCells.length; cellIndex++){
			var newBoard = AiMove(board, choices[choiceIndex], possibleCells[cellIndex]);
			var high = MinMaxMove(true, levelsLeft-1, newBoard, {});
			if(high <= bestHigh){
				bestChoice = choices[choiceIndex];
				bestCell = possibleCells[cellIndex];
				bestHigh = high;
			}
		}
	}

	return bestHigh;
}

function AiMove(sourceBoard, choice, cell){
	var board = CopyBoard(sourceBoard);

	board[cell.x][cell.y] = choice;
	return board;
}

function ComputePossibleCells(board){
	var cells = [];
	for(var x = 0; x < 4; x++){
		for(var y = 0; y < 4; y++){
			if(board[x][y] == 0)
			{
				var cell = {x:x, y:y};
				cells.push(cell);
			}
		}	
	}
	return cells;
}


function HumanTurn(levelsLeft, board, playerMove)
{

	var bestMove = 0;
	var bestHigh = MIN_BOARD_SCORE;
	var moves = GetPossibleHumanMoves(board);

	if(moves.length == 0)
	{
		return FindMaxValue(board);
	}

	for(var i = 0; i < 4; i++){
		var move = moves[i];
		var newBoard = HumanMove(board, move);
		var high = MinMaxMove(false, levelsLeft-1, newBoard, {});
		if(high >= bestHigh){
			bestMove = move;
			bestHigh = high;
		}
	}
	playerMove.move = bestMove;

	return bestHigh;
}

function IsSameBoard(a, b){
	for(var x = 0; x < 4; x++){
		for(var y = 0; y < 4; y++){
			if(a[x][y] != b[x][y]) return false;
		}	
	}
	return true;
}


function CopyBoard(sourceBoard)
{
	var board = [
			[0,0,0,0],
			[0,0,0,0],
			[0,0,0,0],
			[0,0,0,0]
		    ];
	for(var x = 0; x < 4; x++){
		for(var y = 0; y < 4; y++){
			board[x][y] = sourceBoard[x][y];
		}	
	}
	return board;
}

function GetPossibleHumanMoves(sourceBoard){
	var possMoves = [];
	var moves = [0, 1, 2, 3];
	for(var i = 0; i < 4; i++){
		var move = moves[i];
		var newBoard = HumanMove(sourceBoard, move);
		if(!IsSameBoard(sourceBoard, newBoard)){
			possMoves.push(move);
		}
	}
	return moves;
}

function HumanMove(sourceBoard, move)
{

	var board = CopyBoard(sourceBoard);
// 0: up
// 1: right
// 2: down
// 3: left
	if(move == 0)
	{
		// merge upwards
		for(var x = 0; x < 4; x++){
			for(var y = 0; y < 3; y++){
				if(board[x][y] == board[x][y+1]){
					board[x][y] = board[x][y] * 2;
					board[x][y+1] = 0;
				}else if(board[x][y] == 0 ){
					board[x][y] = board[x][y+1];
					board[x][y+1] = 0;
				}
			}
		}
	}else if(move == 1){

		// merge right
		for(var x = 3; x > 0; x--){
			for(var y = 0; y < 4; y++){
				if(board[x][y] == board[x-1][y]){
					board[x][y] = board[x][y] * 2;
					board[x-1][y] = 0;
				}else if(board[x][y] == 0 ){
					board[x][y] = board[x-1][y];
					board[x-1][y] = 0;
				}
			}
		}

	}else if(move == 2)
	{
		// merge downwards
		for(var x = 0; x < 4; x++){
			for(var y = 3; y > 0; y--){
				if(board[x][y] == board[x][y-1]){
					board[x][y] = board[x][y] * 2;
					board[x][y-1] = 0;
				}else if(board[x][y] == 0 ){
					board[x][y] = board[x][y-1];
					board[x][y-1] = 0;
				}
			}
		}
	}else if(move == 3){

		// merge left
		for(var x = 0; x < 3 ; x++){
			for(var y = 0; y < 4; y++){
				if(board[x][y] == board[x+1][y]){
					board[x][y] = board[x][y] * 2;
					board[x+1][y] = 0;
				}else if(board[x][y] == 00){
					board[x][y] = board[x+1][y];
					board[x+1][y] = 0;
				}
			}
		}

	}

	return board;
}

//takes two cell values
function IsPossibleMerge(a, b){
	return a == b && a != 0;
}

function IsEmpty(a){
	return a == 0;
}




function ExtractBoard(){
	var board = [
			[0,0,0,0],
			[0,0,0,0],
			[0,0,0,0],
			[0,0,0,0],
		    ];
	for(var x = 0; x < 4; x++){
		for(var y = 0; y < 4; y++){
			var tile = GetTileAt(x,y);
			if(typeof tile != "undefined" && tile !== null){
				board[x][y] = tile.value;
			}else{
				board[x][y] = 0;
			}
		}	
	}
	return board;
}
 


function FindMaxValue(board){
	var max = 0;
	var occurences = 0;
	var totalPossible = 0;
	var totalUnusable = 0;
	var anyEmpty = false;

	var cellValue = -1;
	var possMergeValue = 10;
	var unusableValue = 2;
	var emptyCellValue = 100;

	for(var x = 0; x < 4; x++){
		for(var y = 0; y < 4; y++){
			if(board[x][y] != 0){
				max += (board[x][y]) * cellValue;

				if((x > 0 && x < 3 && y > 0 && y < 3) && board[x][y] != 0)
				{
					if(board[x][y] == board[x-1][y]) { totalPossible += board[x][y] * possMergeValue; } else if(board[x-1][y] != 0) { totalUnusable += board[x][y] * unusableValue; }
					if(board[x][y] == board[x+1][y]) { totalPossible += board[x][y] * possMergeValue; } else if(board[x+1][y] != 0) { totalUnusable += board[x][y] * unusableValue; }
					if(board[x][y] == board[x][y-1]) { totalPossible += board[x][y] * possMergeValue; } else if(board[x][y-1] != 0) { totalUnusable += board[x][y] * unusableValue; }
					if(board[x][y] == board[x][y+1]) { totalPossible += board[x][y] * possMergeValue; } else if(board[x][y+1] != 0) { totalUnusable += board[x][y] * unusableValue; }
				}

				if(x == 0 && y == 0)
				{
					if(board[x][y] == board[x+1][y]) { totalPossible += board[x][y] * possMergeValue; } else if(board[x+1][y] != 0) { totalUnusable += board[x][y] * unusableValue; }
					if(board[x][y] == board[x][y+1]) { totalPossible += board[x][y] * possMergeValue; } else if(board[x][y+1] != 0) { totalUnusable += board[x][y] * unusableValue; }
				}

				if(x == 3 && y == 0){			
					if(board[x][y] == board[x-1][y]) { totalPossible += board[x][y] * possMergeValue; } else if(board[x-1][y] != 0) { totalUnusable += board[x][y] * unusableValue; }
					if(board[x][y] == board[x][y+1]) { totalPossible += board[x][y] * possMergeValue; } else if(board[x][y+1] != 0) { totalUnusable += board[x][y] * unusableValue; }
				}

				if(x == 0 && y == 3)
				{
					if(board[x][y] == board[x+1][y]) { totalPossible += board[x][y] * possMergeValue; } else if(board[x+1][y] != 0) { totalUnusable += board[x][y] * unusableValue; }
					if(board[x][y] == board[x][y-1]) { totalPossible += board[x][y] * possMergeValue; } else if(board[x][y-1] != 0) { totalUnusable += board[x][y] * unusableValue; }
				}
	
				if(x == 3 && y == 3){
					if(board[x][y] == board[x-1][y]) { totalPossible += board[x][y] * possMergeValue; } else if(board[x-1][y] != 0) { totalUnusable += board[x][y] * unusableValue; }
					if(board[x][y] == board[x][y-1]) { totalPossible += board[x][y] * possMergeValue; } else if(board[x][y-1] != 0) { totalUnusable += board[x][y] * unusableValue; }
				}
			}
			else 
			{	
				max += (emptyCellValue);
				anyEmpty = true;
			}
			if(board[x][y] == 2048)
			{
				return MAX_BOARD_SCORE;
			}
		}	
	}


	if(!anyEmpty){
		console.log("Scoring found board full up.");
		return MIN_BOARD_SCORE;
	}
	

	return  max + totalPossible - totalUnusable;
}




function DumpBoard(board){

	for(var y = 0; y < 4; y++){
		var line = "| ";
		for(var x = 0; x < 4; x++){
			line =  line + board[x][y] + " | ";
		}
		console.log(line);
	}
}

function GetTileAt(x,y){
      var cell = { x: x, y: y };
      return  gm.grid.cellContent(cell);
}


var stopId = setTimeout(sim, 1000);



